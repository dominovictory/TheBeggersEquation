<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: monospace; }
        #ui { 
            position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.85); 
            color: #ffaa00; padding: 15px; border: 1px solid #ffaa00; border-radius: 8px;
            pointer-events: auto; width: 250px; z-index: 100;
        }
        input[type=range] { width: 100%; accent-color: #ffaa00; }
    </style>
</head>
<body>
    <div id="ui">
        <b>UNIFIED AGENT ENGINE (v4.1)</b><br>
        ACTORS: <span id="pop">0</span> | KIDS: <span id="kids">0</span>
        <hr>
        <div style="font-size:0.8em">PURPOSE (G/P RATIO)</div>
        <input type="range" id="pressureSlider" min="0.0" max="1.0" step="0.01" value="0.55">
        <div id="pressureVal" style="text-align:center">0.55</div>
        <div style="font-size:0.7em; color:#888; margin-top:5px; text-align:center;">Agents carve the substrate.</div>
    </div>

<script>
let grid, nextGrid;
const SCALE = 8; // Restored to Dominos scale
let cols, rows;
let PURPOSE = 0.55;
let hosts = [];
let resources = [];
const maxPop = 5000;

function setup() {
    createCanvas(windowWidth, windowHeight);
    cols = Math.ceil(width / SCALE);
    rows = Math.ceil(height / SCALE);
    grid = new Float32Array(cols * rows);
    nextGrid = new Float32Array(cols * rows);
    
    // Initial population
    for (let i = 0; i < 1500; i++) {
        hosts.push(new Host(random(width), random(height), random(1) > 0.5 ? 0 : 1, false));
    }
}

function draw() {
    // 1. UPDATE MATHEMATICAL FIELD
    updateField();
    
    // 2. DRAW SUBSTRATE (High Contrast Dominos Style)
    background(0);
    noStroke();
    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            let val = grid[y * cols + x];
            if (val > 0.1) {
                // Visualize phases: Red (Dying) -> Orange (Stable) -> White (Thriving)
                if (val < 0.4) fill(val * 150, 0, 0); 
                else if (val < 0.7) fill(255, val * 180, 0);
                else fill(255, 255, 200);
                rect(x * SCALE, y * SCALE, SCALE, SCALE);
            }
        }
    }

    // 3. AGENT STIGMERGY: Agents "stamp" the grid as they move
    // This allows them to create their own channels/barriers
    for (let h of hosts) {
        let gx = floor(h.pos.x / SCALE);
        let gy = floor(h.pos.y / SCALE);
        let i = gy * cols + gx;
        if (i >= 0 && i < grid.length) {
            grid[i] += 0.3; // Agents increase local density
        }
    }

    // 4. UPDATE AGENTS & RESOURCES
    if (frameCount % 30 == 0 && resources.length < 30) {
        resources.push(createVector(random(width), random(height)));
    }

    fill(255, 0, 255);
    resources.forEach(r => ellipse(r.x, r.y, 10, 10));

    let kidCount = 0;
    for (let i = hosts.length - 1; i >= 0; i--) {
        let h = hosts[i];
        if (h.isChild) kidCount++;
        h.update();
        h.display();
        
        // Harvesting Logic
        if (h.state === 0 && !h.isChild) {
            for (let j = resources.length - 1; j >= 0; j--) {
                if (distSq(h.pos, resources[j]) < 400) {
                    resources.splice(j, 1);
                    h.energy += 50;
                }
            }
        }
    }

    document.getElementById('pop').innerText = hosts.length;
    document.getElementById('kids').innerText = kidCount;
    document.getElementById('pressureVal').innerText = PURPOSE.toFixed(2);
}

function updateField() {
    const IDEAL = 2.6; // Geometric sweet spot
    const TOLERANCE = 1.5 * (1.0 - PURPOSE);
    const minN = IDEAL - TOLERANCE;
    const maxN = IDEAL + TOLERANCE;

    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            let n = countNeighbors(x, y);
            let i = y * cols + x;
            
            // G/P Filter
            let target = (n > minN && n < maxN) ? 1.0 : 0.0;
            
            // Fluid transition with entropy decay
            let current = grid[i];
            let next = lerp(current, target, 0.15);
            if (target === 0) next -= 0.01; 
            
            nextGrid[i] = constrain(next, 0, 1.2); 
        }
    }
    grid.set(nextGrid);
}

function countNeighbors(x, y) {
    let sum = 0;
    for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
            if (i === 0 && j === 0) continue;
            let cx = (x + i + cols) % cols;
            let cy = (y + j + rows) % rows;
            sum += grid[cy * cols + cx];
        }
    }
    return sum;
}

class Host {
    constructor(x, y, state, isChild) {
        this.pos = createVector(x, y);
        this.vel = p5.Vector.random2D();
        this.state = state;
        this.isChild = isChild;
        this.isLeader = random(1) < 0.04;
        this.energy = 0;
        this.age = 0;
    }

    update() {
        let gx = floor(this.pos.x / SCALE);
        let gy = floor(this.pos.y / SCALE);
        let fieldValue = grid[gy * cols + gx] || 0;

        // FIELD INFLUENCE: Pressure dictates speed
        let speedMult = map(fieldValue, 0, 1, 0.6, 2.5);

        if (this.isChild) {
            this.age++;
            if (this.age > 400) this.isChild = false;
        } else {
            // Seekers (Blue) move toward food
            if (this.state === 0) {
                let closest = null; let d = 100000;
                resources.forEach(r => {
                    let dst = distSq(this.pos, r);
                    if (dst < d) { d = dst; closest = r; }
                });
                if (closest) {
                    let desired = p5.Vector.sub(closest, this.pos);
                    this.vel.lerp(desired, 0.05);
                }
            }

            // Birth logic: High pressure fields + Gold state
            if (this.state === 1 && fieldValue > 0.8 && hosts.length < maxPop && random(1) < 0.01) {
                hosts.push(new Host(this.pos.x, this.pos.y, 1, true));
            }
        }

        this.vel.limit(this.isLeader ? 2.8 * speedMult : 2.0 * speedMult);
        this.pos.add(this.vel);
        this.edges();
    }

    display() {
        strokeWeight(this.isLeader ? 10 : 7);
        // High visibility colors
        if (this.isChild) stroke(255, 150, 200);
        else stroke(this.state === 1 ? '#ffaa00' : '#00ccff');
        point(this.pos.x, this.pos.y);
    }

    edges() {
        if (this.pos.x > width) this.pos.x = 0; if (this.pos.x < 0) this.pos.x = width;
        if (this.pos.y > height) this.pos.y = 0; if (this.pos.y < 0) this.pos.y = height;
    }
}

function distSq(v1, v2) { return (v1.x - v2.x)**2 + (v1.y - v2.y)**2; }

document.getElementById('pressureSlider').addEventListener('input', (e) => {
    PURPOSE = parseFloat(e.target.value);
});
</script>
</body>
</html>