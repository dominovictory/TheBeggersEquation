<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Empire Earth: The Grand Structure</title>
    <style>
        body { margin: 0; background: #050505; overflow: hidden; color: #ffaa00; font-family: 'Courier New', monospace; }
        canvas { display: block; width: 100vw; height: 100vh; image-rendering: pixelated; }
        #ui { 
            position: absolute; top: 20px; left: 20px; 
            background: rgba(0,0,0,0.9); padding: 20px; 
            border: 1px solid #ffaa00; border-radius: 4px;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.2);
            pointer-events: none;
            width: 250px;
        }
        .title { font-size: 1.1em; font-weight: bold; color: #fff; border-bottom: 1px solid #555; padding-bottom: 10px; margin-bottom: 10px; letter-spacing: 1px;}
        .stat { display: flex; justify-content: space-between; font-size: 0.9em; margin-bottom: 5px; color: #aaa; }
        .stat span { color: #fff; }
        .controls { margin-top: 15px; border-top: 1px solid #555; padding-top: 10px; font-size: 0.8em; color: #888; }
        
        /* Snapshot Button */
        #snapBtn {
            pointer-events: auto;
            background: #ffaa00; color: #000; border: none; padding: 8px 12px;
            font-weight: bold; cursor: pointer; width: 100%; margin-top: 10px;
            text-transform: uppercase; letter-spacing: 1px;
        }
        #snapBtn:hover { background: #fff; }
    </style>
</head>
<body>

<div id="ui">
    <div class="title">EMPIRE EARTH</div>
    <div class="stat">System: <span>Stable</span></div>
    <div class="stat">Scale: <span id="scale-stat">8.0</span></div>
    <div class="stat">Matter: <span id="matter-stat">0</span></div>
    
    <div class="controls">
        [Scroll] Zoom In/Out<br>
        [Click] Inject Chaos (C!)<br>
    </div>
    <button id="snapBtn">Take Snapshot</button>
</div>

<canvas id="sim"></canvas>

<script>
/**
 * EMPIRE EARTH: ULTIMATE EDITION
 * The final synthesis of The Begger's Equation.
 * Features: Infinite Zoom, Legacy, Mortality, Snapshot.
 */

const canvas = document.getElementById('sim');
const ctx = canvas.getContext('2d');

// -- THE LAWS OF PHYSICS --
const SPEED = 0.2;           // Fluidity
const DECAY = 0.02;          // Entropy
const MORTALITY = 0.85;      // Death Age
const GLOBAL_PURPOSE = 0.55; // The Magic Number (Stability)

// -- STATE --
let SCALE = 8; 
let width, height; 
let grid, nextGrid;
let ageGrid, nextAgeGrid;

function init() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    width = Math.ceil(canvas.width / SCALE);
    height = Math.ceil(canvas.height / SCALE);
    
    grid = new Float32Array(width * height);
    nextGrid = new Float32Array(width * height);
    ageGrid = new Float32Array(width * height);
    nextAgeGrid = new Float32Array(width * height);
    
    // The Spark (Center Seed)
    let cx = Math.floor(width/2);
    let cy = Math.floor(height/2);
    for(let y=cy-20; y<cy+20; y++){
        for(let x=cx-20; x<cx+20; x++){
            if(Math.random()>0.5) {
                let i = y*width+x;
                grid[i] = 1.0; 
                ageGrid[i] = 0.0;
            }
        }
    }
    updateStats();
}

// -- INFINITE ZOOM ENGINE --
function applyZoom(delta) {
    let oldScale = SCALE;
    let newScale = oldScale + delta;
    if (newScale < 1.0) newScale = 1.0; // Allow massive zoom out
    if (newScale > 60) newScale = 60; 
    if (newScale === oldScale) return;

    let oldWidth = width;
    let oldHeight = height;
    let newWidth = Math.ceil(window.innerWidth / newScale);
    let newHeight = Math.ceil(window.innerHeight / newScale);

    let newGrid = new Float32Array(newWidth * newHeight);
    let newAge = new Float32Array(newWidth * newHeight);

    let diffX = (newWidth - oldWidth) / 2;
    let diffY = (newHeight - oldHeight) / 2;
    
    for (let y = 0; y < oldHeight; y++) {
        for (let x = 0; x < oldWidth; x++) {
            let nx = Math.floor(x + diffX);
            let ny = Math.floor(y + diffY);
            if (nx >= 0 && nx < newWidth && ny >= 0 && ny < newHeight) {
                let oldIdx = y * oldWidth + x;
                let newIdx = ny * newWidth + nx;
                newGrid[newIdx] = grid[oldIdx];
                newAge[newIdx] = ageGrid[oldIdx];
            }
        }
    }

    SCALE = newScale;
    width = newWidth;
    height = newHeight;
    grid = newGrid;
    ageGrid = newAge;
    
    nextGrid = new Float32Array(width * height);
    nextAgeGrid = new Float32Array(width * height);

    updateStats();
}

function idx(x, y, w, h) {
    if (x < 0) x = 0; if (x >= w) x = w - 1;
    if (y < 0) y = 0; if (y >= h) y = h - 1;
    return y * w + x;
}

// -- THE SIMULATION LOOP --
function update() {
    let totalMatter = 0;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = y * width + x;
            
            // Physics: Uniform Purpose + Legacy Shield
            let rawPurpose = GLOBAL_PURPOSE; 
            let experience = ageGrid[i];
            let shield = Math.min(experience, 0.20); 
            let localPurpose = Math.max(rawPurpose - shield, 0.4);

            // The Begger's Equation
            const IDEAL = 2.6; 
            const TOLERANCE = 1.6 * (1.0 - localPurpose); 
            const minN = IDEAL - TOLERANCE;
            const maxN = IDEAL + TOLERANCE;

            let neighbors = 0;
            neighbors += grid[idx(x-1, y-1, width, height)]; 
            neighbors += grid[idx(x  , y-1, width, height)]; 
            neighbors += grid[idx(x+1, y-1, width, height)];
            neighbors += grid[idx(x-1, y  , width, height)];                                   
            neighbors += grid[idx(x+1, y  , width, height)];
            neighbors += grid[idx(x-1, y+1, width, height)]; 
            neighbors += grid[idx(x  , y+1, width, height)]; 
            neighbors += grid[idx(x+1, y+1, width, height)];

            let state = grid[i];
            let age = ageGrid[i];
            let target = 0;

            if (neighbors > minN && neighbors < maxN) {
                target = 1.0; 
                nextAgeGrid[i] = age + 0.005; 
            } else {
                target = 0.0;
                nextAgeGrid[i] = age * 0.95; 
            }

            if (age > MORTALITY) {
                target = 0.0;
                nextAgeGrid[i] = 0; // Death resets the cycle
            }

            let delta = (target - state) * SPEED;
            if (target === 0) delta -= DECAY;
            let newState = state + delta;
            if (newState < 0) newState = 0;
            if (newState > 1) newState = 1;

            nextGrid[i] = newState;
            totalMatter += newState;
        }
    }

    let temp = grid; grid = nextGrid; nextGrid = temp;
    let tempAge = ageGrid; ageGrid = nextAgeGrid; nextAgeGrid = tempAge;
    
    document.getElementById('matter-stat').innerText = Math.floor(totalMatter).toLocaleString();
}

function draw() {
    ctx.fillStyle = "#050505";
    ctx.fillRect(0,0, canvas.width, canvas.height);

    const imgData = ctx.getImageData(0, 0, width, height);
    const data = imgData.data;

    for (let i = 0; i < width * height; i++) {
        let val = grid[i];
        let p = i * 4;
        
        if (val < 0.1) {
            data[p]=0; data[p+1]=0; data[p+2]=0; 
        } else {
            // "The Magma & The Ice" Palette
            let age = ageGrid[i];
            if (age < 0.2) {
                // Chaos (Orange/Red)
                data[p] = 255; data[p+1] = val*120; data[p+2] = 0; 
            } else if (age < 0.6) {
                // Structure (Teal/Cyan)
                data[p] = 0; data[p+1] = 200; data[p+2] = 180 + (val*75); 
            } else {
                // Legacy (White/Gold)
                data[p] = 255; data[p+1] = 255; data[p+2] = 240; 
            }
            data[p+3] = 255;
        }
    }
    
    // High-Quality Upscaling
    createImageBitmap(imgData).then(bitmap => {
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
    });
}

function updateStats() {
    document.getElementById('scale-stat').innerText = SCALE.toFixed(1);
}

// -- INTERACTION --

// Zoom
window.addEventListener('wheel', e => {
    let direction = e.deltaY > 0 ? -0.5 : 0.5; // Smoother zoom
    applyZoom(direction);
});

// God Mode (Paint)
let mouseDown = false;
canvas.addEventListener('mousedown', () => mouseDown = true);
canvas.addEventListener('mouseup', () => mouseDown = false);
canvas.addEventListener('mousemove', e => {
    if (!mouseDown) return;
    let x = Math.floor((e.clientX / canvas.width) * width);
    let y = Math.floor((e.clientY / canvas.height) * height);
    for(let dy=-2; dy<=2; dy++){
        for(let dx=-2; dx<=2; dx++){
             let i = idx(x+dx, y+dy, width, height);
             grid[i] = 1.0; 
             ageGrid[i] = 0.3; 
        }
    }
});

// Snapshot Function
document.getElementById('snapBtn').addEventListener('click', () => {
    let link = document.createElement('a');
    link.download = 'empire_earth_' + Date.now() + '.png';
    link.href = canvas.toDataURL();
    link.click();
});

init();
function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>